#!/usr/bin/env python

import argparse
import json
from getpass import getpass, getuser
from os import getenv, urandom
from os.path import expanduser, isfile, join
import string
import subprocess
from sys import exit, platform
import time

VERSION = '0.1.0'
USAGE = '''pick - minimal password manager

Options:
    -h, --help
    -v, --version

Usage:
    pick -c, --copy   <alias>
    pick -d, --delete <alias>
    pick -l, --list
    pick -r, --read   <alias>
    pick -w, --write  [<alias>] [<username>] [<password>]

The most commonly used pick commands are:
    copy        Copy a credential password to the clipboard
    write       Write a new credential to the safe
    read        Read a credential from the safe
    list        List all credentials in the safe
    delete      Delete a credential from the sfae
'''

parser = argparse.ArgumentParser(description='minimal password manager.', usage=USAGE)
parser.add_argument('alias', nargs='?', help='Copy a credential password to the clipboard')
parser.add_argument('-c', '--copy', help='Copy a credential password to the clipboard')
parser.add_argument('-w', '--write', nargs='*', help='Write a new credential to the safe')
parser.add_argument('-r', '--read', help='Read a credential from the safe')
parser.add_argument('-l', '--list', action='store_true', help='List all credentials in the safe')
parser.add_argument('-d', '--delete', help='Delete a credential from the safe')
parser.add_argument('-v', '--version', action='version', version='pick version %s' % VERSION)

class Pick():
  def __init__(self, password, safe, config):
    self.password = password
    self.safe = safe
    self.config = config

  def write_safe(self, json_data):
    ''' Writes the given data to an ecrypted file using gpg '''
    with open('/dev/null', 'w') as null:
      # Send the data to encrypt into a pipe
      cmd1 = 'echo %s' % json.dumps(json_data)
      ps = subprocess.Popen(cmd1.split(), stdout=subprocess.PIPE)

      # Then encrypt the data from stdin
      cmd2 = 'gpg --symmetric --armor --batch --yes --passphrase %s --output %s' % (self.password, self.safe)
      ps2 = subprocess.check_output(cmd2.split(), stdin=ps.stdout, stderr=null)

  def read_safe(self):
    ''' Decrypts the safe and returns the parsed JSON '''
    if not isfile(self.safe):
      if not get_answer('No safe found at %s, create one?' % self.safe):
        die('You must create a safe', 100)
      else:
        print self.initialize_safe()

    with open('/dev/null', 'w') as null:
      cmd= 'gpg --decrypt --batch --armor --passphrase %s %s' % (self.password, self.safe)
      p1 = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=null)
      secrets, err = p1.communicate()

      if err: 
        die(err, 102)

    try:
      return json.loads(secrets)
    except ValueError:
      die('Unable to read safe at %s' % self.safe, 101)

  def read_credential(self, alias):
    ''' Reads a credential by alias '''
    safe = self.read_safe()

    if alias not in safe['data']:
      die('Credential not found')

    return safe['data'][alias]

  def write_credential(self, alias=None, username=None, password=None):
    ''' Writes a credential by alias '''
    safe = self.read_safe()

    # 1. Make sure there's an alias
    if not alias:
      alias = get_input('Enter an Alias')

    # 1a. Confirm before overwriting an existing credential
    alias_exists = alias in safe['data']
    if (
            alias_exists and 
            not get_answer('%s already exists, do you want to overwrite' % alias)
        ): die()

    # 2. Make sure there's a username
    if not username:
      username = get_input('Enter the account username (username/email/etc)')

    # 3. Make sure there's a password
    if not password:
      if get_answer('Generate password'):
        password = self.generate_password()
      else:
        password = getpass('Enter the password\n> ')

    now = int(time.time())

    # 4. Create the credential
    if alias_exists:
      safe['data'][alias]['username'] = username
      safe['data'][alias]['password'] = password 
      safe['data'][alias]['modified_on'] = now
    else:
      safe['data'][alias] = {
              'alias': alias,
              'username': username,
              'password': password,
              'created_on': now,
              'modified_on': now
              }

    # 5. Save it
    self.write_safe(safe)
    return 'Credential saved'

  def delete_credential(self, alias):
    """ Deletes a credential from the safe """
    safe = self.read_safe()

    if not alias in safe['data']:
      die('Alias not found')

    del safe['data'][alias]
    self.write_safe(safe)
    return 'Credential deleted'

  def initialize_safe(self):
    ''' Creates a new safe with default values '''
    self.write_safe({
        'created_on': int(time.time()), 
        'created_by': getuser(), 
        'data':{}
    })

    return 'Safe created!'

  def generate_password(self, length=50):
    ''' Generates a random password of length '''
    rand_max = 256
    rand_excess = (rand_max + 1) % length
    rand_limit = rand_max - rand_excess
    chars = string.uppercase + string.lowercase + string.punctuation + string.letters

    def next_index():
      while True:
        x = ord(urandom(1))
        if x <= rand_limit:
          return x % length

    return ''.join(chars[next_index()] for _ in range(length))
    

def pretty_print(json_data):
  ''' Pretty prints JSON '''
  print json.dumps(json_data, sort_keys=True, indent=4, separators=(',', ': '))

def get_platform():
  ''' Get the plaform we're running on '''
  if platform in ['linux', 'linux2']:
    return 'linux'
  elif platform == "darwin":
    return 'osx'
  else: 
    die('Unsupported platform %s' % platform)

def copy_to_clipboard(text):
  ''' Copy the given text to the clipboard '''
  if get_platform() == 'linux':
    process = subprocess.Popen(['xclip', '-sel', 'clip'], stdin=subprocess.PIPE)
  else:
    # Assumes OS X
    process = subprocess.Popen('pbcopy', stdin=subprocess.PIPE)

  process.communicate(text.encode('utf-8'))

def die(message='', code=100):
  print message
  exit(code)

def get_input(prompt):
  return raw_input('%s\n> ' % prompt)

def get_answer(prompt, default='y'):
  ''' Gets a y/n answer for the prompt '''
  answer = raw_input('%s? (y/n)\n> ' % prompt)
  if not answer: 
    answer = default

  return answer.lower().strip() == 'y'

def get_master_password():
  ''' Loads the password from the environment or prompts the user for it '''
  password = getenv('PICK_TOKEN', None)
  return password if password else getpass('Enter password\n> ')

def get_safe_path():
  ''' Loads the safe path from the environment or uses the default location '''
  default_safe_file = join(expanduser('~'), '.pick.safe')
  return getenv('PICK_SAFE', default_safe_file)

def get_config():
  ''' Loads the configuration from the environment or uses defaults '''
  try:
    config = json.loads(getenv('PICK_CONFIG', '{}'))

    if 'silent' not in config:
      config['silent'] = False

    return config
  except ValueError:
    die('Unable to read PICK_CONFIG', 101)


if __name__=='__main__':
  args = parser.parse_args()

  pick = Pick(
          password = get_master_password(),
          safe = get_safe_path(),
          config = get_config()
          )

  if args.copy is not None:
    alias = args.copy
    credential = pick.read_credential(alias)
    copy_to_clipboard(credential['password'])

  elif args.write is not None:
    if len(args.write) == 3:
        alias, username, password = args.write
    elif len(args.write) == 2:
        alias, username = args.write; password = None
    elif len(args.write) == 1:
        alias = args.write[0]; password = None; username = None
    else:
        alias, username, password = [None, None, None]

    print pick.write_credential(alias, username, password)
  
  elif args.read is not None:
    alias = args.read
    pretty_print(pick.read_credential(alias))

  elif args.list is not False:
    safe = pick.read_safe()
    credentials = safe['data']
    pretty_print(credentials)

  elif args.delete is not None:
    alias = args.delete
    print pick.delete_credential(alias)
  else:
    print USAGE
